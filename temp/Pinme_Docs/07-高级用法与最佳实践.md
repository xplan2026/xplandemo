# 高级用法与最佳实践

本指南涵盖高级技巧、优化策略与更专业的工作流，帮助你充分发挥 PinMe 的能力。

## 性能优化
### 文件压缩
#### 图片优化
```bash
# 使用 ImageMagick（安装：brew install imagemagick）
# 压缩 JPEG
mogrify -quality 85 -resize 80% *.jpg

# 压缩 PNG
mogrify -quality 95 -resize 80% *.png

# 转换为 WebP（更小体积，同等质量）
cwebp -q 80 image.jpg -o image.webp
```
#### CSS/JS 最小化
```bash
# 使用 Node.js 工具
npm install -g minify uglify-js clean-css-cli

# 最小化 JavaScript
uglifyjs app.js -o app.min.js

# 最小化 CSS
cleancss -o styles.min.css styles.css

# 最小化 HTML
html-minifier --collapse-whitespace --remove-comments index.html -o index.min.html
```
## 目录结构优化
### 推荐目录结构
```bash
my-project/
├── dist/                    # 生产构建产物
│   ├── index.html          # 入口文件
│   ├── assets/             # 静态资源
│   │   ├── css/
│   │   ├── js/
│   │   └── images/
│   └── sw.js               # Service Worker（可选）
├── src/                     # 源码
├── public/                  # 公共资源
└── docs/                   # 文档
```
### 资源分包（Bundling）
```js
// webpack.config.js
module.exports = {
  mode: 'production',
  output: {
    path: path.resolve(__dirname, 'dist'),
    filename: 'assets/js/[name].[contenthash].js'
  },
  optimization: {
    splitChunks: {
      chunks: 'all',
      cacheGroups: {
        vendor: {
          test: /[\\/]node_modules[\\/]/,
          name: 'vendors',
          chunks: 'all'
        }
      }
    }
  }
};
```
## 各框架配置建议
### Vite 项目
必要配置
```js
// vite.config.js
import { defineConfig } from 'vite'

export default defineConfig({
  base: './',                    // 对 IPFS 部署至关重要
  build: {
    outDir: 'dist',
    assetsDir: 'assets',
    sourcemap: false,            // 生产环境不建议带 sourcemap
    minify: 'terser',
    rollupOptions: {
      output: {
        manualChunks: {
          vendor: ['react', 'react-dom']
        }
      }
    }
  },
  plugins: [
    // 按需添加优化插件
  ]
})
```
### 构建并部署脚本
```bash
#!/bin/bash
# deploy-vite.sh

# 清理旧构建
rm -rf dist

# 生产构建
npm run build

# 图片优化（可选）
# find dist/assets -name "*.png" -exec pngquant --quality=65-80 --output {} --force {} \;

# 部署到 PinMe
pinme upload ./dist --domain my-vite-app

echo " Vite app deployed successfully!"
```

### React 应用
CRA（Create React App）配置
```json
// package.json
{
  "homepage": ".",  // 对 IPFS 兼容性至关重要
  "scripts": {
    "build": "react-scripts build",
    "deploy": "npm run build && pinme upload ./build --domain my-react-app"
  }
}
```
### 按环境构建
```js
// config/build.js
const path = require('path');

const config = {
  production: {
    domain: 'my-app-prod',
    buildDir: 'build'
  },
  staging: {
    domain: 'my-app-staging',
    buildDir: 'build-staging'
  }
};

module.exports = config[(process.env.NODE_ENV || 'production')];
```
### Next.js 静态导出
#### Next.js 配置
```js
// next.config.js
module.exports = {
  output: 'export',
  trailingSlash: true,
  images: {
    unoptimized: true  // 静态导出必需
  },
  assetPrefix: '.',   // 对 IPFS 至关重要
  basePath: ''        // 如有需要可调整
}
```
#### 导出并部署
```bash
#!/bin/bash
# deploy-nextjs.sh

# 导出静态站点
npm run build
npm run export  # or: next export

# 输出目录为 out
pinme upload ./out --domain my-next-app

echo " Next.js static site deployed!"
```
### Vue.js 应用
#### Vue CLI 配置
```js
// vue.config.js
module.exports = {
  publicPath: './',  // 对 IPFS 至关重要
  outputDir: 'dist',
  assetsDir: 'assets',
  productionSourceMap: false,
  
  configureWebpack: {
    optimization: {
      splitChunks: {
        chunks: 'all'
      }
    }
  }
}
```
## 高级工作流
### CI/CD 集成
#### GitHub Actions
```yaml
# .github/workflows/deploy.yml
name: Deploy to PinMe

on:
  push:
    branches: [main]
  pull_request:
    branches: [main]

jobs:
  deploy:
    runs-on: ubuntu-latest
    
    steps:
    - uses: actions/checkout@v3
    
    - name: Setup Node.js
      uses: actions/setup-node@v3
      with:
        node-version: '18'
        cache: 'npm'
    
    - name: Install dependencies
      run: npm ci
    
    - name: Build project
      run: npm run build
    
    - name: Install PinMe
      run: npm install -g pinme
    
    - name: Deploy to PinMe
      env:
        PINME_APPKEY: ${{ secrets.PINME_APPKEY }}
      run: |
        pinme set-appkey $PINME_APPKEY
        pinme upload ./dist --domain my-app-${{ github.sha }}
    
    - name: Update production domain
      if: github.ref == 'refs/heads/main'
      env:
        PINME_APPKEY: ${{ secrets.PINME_APPKEY }}
      run: |
        pinme set-appkey $PINME_APPKEY
        pinme upload ./dist --domain my-app
GitLab CI
# .gitlab-ci.yml
stages:
  - build
  - deploy

build:
  stage: build
  image: node:18
  script:
    - npm ci
    - npm run build
  artifacts:
    paths:
      - dist/

deploy:
  stage: deploy
  image: node:18
  dependencies:
    - build
  script:
    - npm install -g pinme
    - pinme set-appkey $PINME_APPKEY
    - pinme upload ./dist --domain my-app-$CI_COMMIT_SHORT_SHA
  only:
    - main
```
### 多环境部署
#### 环境管理脚本
```bash
#!/bin/bash
# deploy-env.sh

ENVIRONMENT=${1:-production}
PROJECT_NAME=${2:-my-app}

case $ENVIRONMENT in
  "production")
    DOMAIN="$PROJECT_NAME-prod"
    BUILD_DIR="dist"
    ;;
  "staging")
    DOMAIN="$PROJECT_NAME-staging"
    BUILD_DIR="dist-staging"
    ;;
  "development")
    DOMAIN="$PROJECT_NAME-dev"
    BUILD_DIR="dist-dev"
    ;;
  *)
    echo "Unknown environment: $ENVIRONMENT"
    echo "Usage: ./deploy-env.sh [production|staging|development] [project-name]"
    exit 1
    ;;
esac

echo "Deploying to $ENVIRONMENT as $DOMAIN..."

# Build for environment
npm run build:$ENVIRONMENT

# Deploy to PinMe
pinme upload ./$BUILD_DIR --domain $DOMAIN

echo " Deployed to $ENVIRONMENT: https://$DOMAIN.pinme.eth.limo"
```
#### 版本管理脚本
```bash
#!/bin/bash
# deploy-versioned.sh

VERSION=$(node -p "require('./package.json').version")
PROJECT_NAME="my-app"

# Build current version
npm run build

# Deploy versioned
pinme upload ./dist --domain $PROJECT_NAME-v$VERSION

# Update latest
pinme upload ./dist --domain $PROJECT_NAME

# Create deployment record
echo "$(date), $VERSION, v$VERSION, latest" >> deployments.log

echo " Deployed version $VERSION"
echo "[WEB] https://$PROJECT_NAME.pinme.eth.limo"
echo "[TAG]  https://$PROJECT_NAME-v$VERSION.pinme.eth.limo"
```
## 自动化测试集成
### 部署前测试
```bash
#!/bin/bash
# test-and-deploy.sh

# Run tests
npm run test

if [ $? -ne 0 ]; then
  echo "[ERROR] Tests failed. Deployment cancelled."
  exit 1
fi

# Run linting
npm run lint

if [ $? -ne 0 ]; then
  echo "[ERROR] Linting failed. Deployment cancelled."
  exit 1
fi

# Build project
npm run build

# Test build locally
npx http-server dist -p 8001 &
SERVER_PID=$!
sleep 2

# Health check
curl -f http://localhost:8001 || {
  echo "[ERROR] Build health check failed"
  kill $SERVER_PID
  exit 1
}

kill $SERVER_PID

# Deploy
pinme upload ./dist --domain my-app
```
## 高级文件管理
### 大文件处理
#### 文件拆分
```bash
#!/bin/bash
# split-large-files.sh

THRESHOLD_MB=19  # 留出 IPFS 开销空间

find . -type f -size +${THRESHOLD_MB}M | while read file; do
  echo "Processing large file: $file"
  
  # Split file into chunks
  split -b ${THRESHOLD_MB}M "$file" "$file.part."
  
  # Create manifest
  echo "{\"original\":\"$file\",\"chunks\":[" > "$file.manifest.json"
  
  # List chunks
  ls "$file.part."* | while read chunk; do
    echo "\"$(basename "$chunk")\"," >> "$file.manifest.json"
  done
  
  # Remove trailing comma and close JSON
  sed '$ s/,$//' "$file.manifest.json" > temp.json
  echo "]}" >> temp.json
  mv temp.json "$file.manifest.json"
  
  # Remove original large file
  rm "$file"
  
  echo "Split into chunks for: $file"
done
```
#### 压缩策略
```bash
#!/bin/bash
# compress-assets.sh

# Compress text files
find ./dist -name "*.js" -exec gzip -k {} \;
find ./dist -name "*.css" -exec gzip -k {} \;
find ./dist -name "*.html" -exec gzip -k {} \;

# Convert images to WebP (if cwebp is available)
if command -v cwebp &> /dev/null; then
  find ./dist -name "*.jpg" -o -name "*.png" | while read img; do
    webp="${img%.*}.webp"
    cwebp -q 80 "$img" -o "$webp"
    rm "$img"  # Remove original
  done
fi

echo " Compression complete"
```
## 安全最佳实践
### 内容安全头
#### 带安全策略的 Service Worker
```js
// sw.js - Service Worker
const CACHE_NAME = 'pinme-app-v1';

self.addEventListener('install', (event) => {
  event.waitUntil(
    caches.open(CACHE_NAME).then((cache) => {
      return cache.addAll([
        '/',
        '/index.html',
        '/assets/css/main.css',
        '/assets/js/main.js'
      ]);
    })
  );
});

// Add security headers through network interception
self.addEventListener('fetch', (event) => {
  event.respondWith(
    fetch(event.request).then((response) => {
      // Add security headers
      const newResponse = new Response(response.body, {
        status: response.status,
        statusText: response.statusText,
        headers: {
          ...response.headers,
          'X-Content-Type-Options': 'nosniff',
          'X-Frame-Options': 'DENY',
          'X-XSS-Protection': '1; mode=block'
        }
      });
      return newResponse;
    }).catch(() => {
      return caches.match(event.request);
    })
  );
});
```
### 敏感数据管理
#### 构建时环境变量
```bash
#!/bin/bash
# secure-build.sh

# Load sensitive config
source .env.production

# Replace placeholders in build
export API_URL="$PROD_API_URL"
export DB_CONFIG="$PROD_DB_CONFIG"

# Build with environment variables
npm run build

# Remove sensitive files before upload
rm -f .env.production
find ./dist -name "*.map" -delete

# Deploy
pinme upload ./dist --domain my-app
```