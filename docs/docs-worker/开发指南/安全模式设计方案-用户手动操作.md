# 安全模式设计方案 - 用户手动操作支持

**版本**: v2.4.1  
**创建日期**: 2026-02-02  
**状态**: 设计中

---

## 📋 问题背景

### 当前保护机制

在已经部署 2 个 Worker 的情况下，现有的保护机制实现了：

- ✅ Worker 每分钟扫描所有钱包
- ✅ 检测到 wkeyDAO/USDT > 0 时立即转移到安全钱包
- ✅ 使用分布式锁防止竞争
- ✅ **结果**：盗币者和用户都无法转移代币

### 用户需求

用户需要能够安全地执行以下操作：

| 需求 | 描述 |
|------|------|
| 1. 充值 USDT | 在 wkeyDAO APP 上充值 USDT 以启动涡轮 |
| 2. 启动涡轮 | 手动在 APP 上启动涡轮 |
| 3. 涡轮结束 | 安全地将涡轮收益转移到安全钱包 |
| 4. 接收本金 | 每天智能合约返还的本金需要从 APP 转移到被保护钱包 |
| 5. 保护本金 | 安全地将转入的本金转移到安全钱包 |

**核心矛盾**：
- Worker 的自动转账会干扰用户的手动操作
- 如果移除自动转账，盗币者可能趁虚而入
- 需要在"安全性"和"可用性"之间找到平衡

---

## 💡 解决方案

### 方案一：临时禁用保护（推荐）

#### 设计思路

用户通过前端 API 临时暂停对指定钱包的保护，在暂停期间 Worker 不执行转账操作。

#### API 设计

##### 1. 暂停保护

**端点**: `POST /pause-wallet`

**请求参数**:
```json
{
  "wallet": "0x1234567890abcdef1234567890abcdef12345678",
  "duration": 300,
  "reason": "启动涡轮"
}
```

**响应**:
```json
{
  "success": true,
  "wallet": "0x1234567890abcdef1234567890abcdef12345678",
  "paused_at": "2026-02-02T10:00:00Z",
  "resumed_at": "2026-02-02T10:05:00Z",
  "reason": "启动涡轮"
}
```

##### 2. 恢复保护

**端点**: `POST /resume-wallet`

**请求参数**:
```json
{
  "wallet": "0x1234567890abcdef1234567890abcdef12345678"
}
```

**响应**:
```json
{
  "success": true,
  "wallet": "0x1234567890abcdef1234567890abcdef12345678",
  "resumed_at": "2026-02-02T10:03:00Z"
}
```

##### 3. 查询钱包状态

**端点**: `GET /wallet-status?wallet=0x...`

**响应**:
```json
{
  "wallet": "0x1234567890abcdef1234567890abcdef12345678",
  "is_paused": true,
  "paused_at": "2026-02-02T10:00:00Z",
  "resumed_at": "2026-02-02T10:05:00Z",
  "remaining_seconds": 120,
  "reason": "启动涡轮"
}
```

#### Worker 修改逻辑

```javascript
// 在 scheduled 触发时，检查钱包是否被暂停
async function scanWallet(env, walletAddress, rpcUrl) {
  // 检查钱包是否被暂停
  const pausedWalletsKey = 'paused_wallets'
  const pausedWalletsData = await env.RPC_POOL.get(pausedWalletsKey)
  
  if (pausedWalletsData) {
    const pausedWallets = JSON.parse(pausedWalletsData)
    const pausedInfo = pausedWallets.find(p => 
      p.wallet.toLowerCase() === walletAddress.toLowerCase()
    )
    
    if (pausedInfo) {
      const now = Math.floor(Date.now() / 1000)
      const pausedAt = pausedInfo.paused_at
      const duration = pausedInfo.duration
      
      if (now - pausedAt < duration) {
        const remaining = duration - (now - pausedAt)
        console.log(`⏸️ 钱包 ${walletAddress.slice(-4)} 已暂停保护，剩余 ${remaining} 秒`)
        
        // 记录暂停状态到 Supabase
        await recordPauseStatus(env, walletAddress, remaining, pausedInfo.reason)
        
        // 跳过扫描和转账
        return { action: 'paused', remaining }
      } else {
        // 暂停时间已过，自动恢复
        console.log(`✅ 钱包 ${walletAddress.slice(-4)} 暂停时间已过，自动恢复保护`)
        
        // 从暂停列表中移除
        const updatedPausedWallets = pausedWallets.filter(p => 
          p.wallet.toLowerCase() !== walletAddress.toLowerCase()
        )
        await env.RPC_POOL.put(pausedWalletsKey, JSON.stringify(updatedPausedWallets))
        
        await recordResumeStatus(env, walletAddress, '自动恢复')
      }
    }
  }
  
  // 继续正常扫描和转账逻辑
  // ... 原有代码 ...
}

/**
 * 记录暂停状态到 Supabase
 */
async function recordPauseStatus(env, walletAddress, remaining, reason) {
  try {
    const db = new DatabaseExtension(env)
    await db.initialize()
    
    await db.supabase.from('wallet_pause_history').insert({
      wallet_address: walletAddress,
      action: 'pause',
      reason: reason,
      remaining_seconds: remaining,
      worker_id: WORKER_ID,
      created_at: new Date().toISOString()
    })
  } catch (error) {
    console.error(`❌ 记录暂停状态失败:`, error.message)
  }
}

/**
 * 记录恢复状态到 Supabase
 */
async function recordResumeStatus(env, walletAddress, reason) {
  try {
    const db = new DatabaseExtension(env)
    await db.initialize()
    
    await db.supabase.from('wallet_pause_history').insert({
      wallet_address: walletAddress,
      action: 'resume',
      reason: reason,
      worker_id: WORKER_ID,
      created_at: new Date().toISOString()
    })
  } catch (error) {
    console.error(`❌ 记录恢复状态失败:`, error.message)
  }
}
```

#### API 处理器实现

```javascript
/**
 * 处理暂停钱包保护
 */
async handlePauseWallet(request, env) {
  const startTime = Date.now()
  
  try {
    const { wallet, duration = 300, reason } = await request.json()
    
    // 验证钱包地址
    if (!/^(0x)?[0-9a-fA-F]{40}$/.test(wallet)) {
      return new Response(JSON.stringify({
        success: false,
        error: 'Invalid wallet address'
      }), { status: 400, headers: this.corsHeaders })
    }
    
    // 验证钱包是否在被保护列表中
    const normalizedWallet = wallet.toLowerCase()
    const isProtected = CONFIG.PROTECTED_WALLETS.includes(normalizedWallet)
    
    if (!isProtected) {
      return new Response(JSON.stringify({
        success: false,
        error: 'Wallet is not in the protected list'
      }), { status: 400, headers: this.corsHeaders })
    }
    
    // 验证时长限制（最多 1 小时）
    if (duration > 3600) {
      return new Response(JSON.stringify({
        success: false,
        error: 'Duration cannot exceed 3600 seconds (1 hour)'
      }), { status: 400, headers: this.corsHeaders })
    }
    
    // 检查每日暂停次数限制
    const db = new DatabaseExtension(env)
    await db.initialize()
    
    const today = new Date().toISOString().split('T')[0]
    const { data: pauseCount } = await db.supabase
      .from('wallet_pause_history')
      .select('id')
      .eq('wallet_address', normalizedWallet)
      .eq('action', 'pause')
      .gte('created_at', `${today}T00:00:00Z`)
      .lt('created_at', `${today}T23:59:59Z`)
    
    if (pauseCount && pauseCount.length >= 5) {
      return new Response(JSON.stringify({
        success: false,
        error: 'Daily pause limit exceeded (5 times per day)'
      }), { status: 429, headers: this.corsHeaders })
    }
    
    // 添加到暂停列表
    const pausedWalletsKey = 'paused_wallets'
    const pausedWalletsData = await env.RPC_POOL.get(pausedWalletsKey)
    let pausedWallets = pausedWalletsData ? JSON.parse(pausedWalletsData) : []
    
    // 移除已存在的记录
    pausedWallets = pausedWallets.filter(p => 
      p.wallet.toLowerCase() !== normalizedWallet
    )
    
    // 添加新记录
    const now = Math.floor(Date.now() / 1000)
    pausedWallets.push({
      wallet: normalizedWallet,
      paused_at: now,
      duration: duration,
      reason: reason || 'Manual pause'
    })
    
    await env.RPC_POOL.put(pausedWalletsKey, JSON.stringify(pausedWallets))
    
    // 记录到 Supabase
    await recordPauseStatus(env, normalizedWallet, duration, reason)
    
    console.log(`⏸️ [${WORKER_ID}] 钱包 ${normalizedWallet.slice(-4)} 已暂停保护，时长 ${duration} 秒`)
    
    return new Response(JSON.stringify({
      success: true,
      wallet: normalizedWallet,
      paused_at: new Date(now * 1000).toISOString(),
      resumed_at: new Date((now + duration) * 1000).toISOString(),
      reason: reason || 'Manual pause'
    }), { 
      status: 200,
      headers: this.corsHeaders
    })
    
  } catch (error) {
    console.error(`❌ [${WORKER_ID}] 暂停钱包保护失败:`, error)
    
    return new Response(JSON.stringify({
      success: false,
      error: error.message
    }), { 
      status: 500,
      headers: this.corsHeaders
    })
  }
}

/**
 * 处理恢复钱包保护
 */
async handleResumeWallet(request, env) {
  const startTime = Date.now()
  
  try {
    const { wallet } = await request.json()
    
    // 验证钱包地址
    if (!/^(0x)?[0-9a-fA-F]{40}$/.test(wallet)) {
      return new Response(JSON.stringify({
        success: false,
        error: 'Invalid wallet address'
      }), { status: 400, headers: this.corsHeaders })
    }
    
    const normalizedWallet = wallet.toLowerCase()
    
    // 从暂停列表中移除
    const pausedWalletsKey = 'paused_wallets'
    const pausedWalletsData = await env.RPC_POOL.get(pausedWalletsKey)
    
    if (!pausedWalletsData) {
      return new Response(JSON.stringify({
        success: false,
        error: 'Wallet is not paused'
      }), { status: 400, headers: this.corsHeaders })
    }
    
    let pausedWallets = JSON.parse(pausedWalletsData)
    const existingIndex = pausedWallets.findIndex(p => 
      p.wallet.toLowerCase() === normalizedWallet
    )
    
    if (existingIndex === -1) {
      return new Response(JSON.stringify({
        success: false,
        error: 'Wallet is not paused'
      }), { status: 400, headers: this.corsHeaders })
    }
    
    pausedWallets.splice(existingIndex, 1)
    
    if (pausedWallets.length === 0) {
      await env.RPC_POOL.delete(pausedWalletsKey)
    } else {
      await env.RPC_POOL.put(pausedWalletsKey, JSON.stringify(pausedWallets))
    }
    
    // 记录到 Supabase
    await recordResumeStatus(env, normalizedWallet, 'Manual resume')
    
    console.log(`▶️ [${WORKER_ID}] 钱包 ${normalizedWallet.slice(-4)} 已恢复保护`)
    
    return new Response(JSON.stringify({
      success: true,
      wallet: normalizedWallet,
      resumed_at: new Date().toISOString()
    }), { 
      status: 200,
      headers: this.corsHeaders
    })
    
  } catch (error) {
    console.error(`❌ [${WORKER_ID}] 恢复钱包保护失败:`, error)
    
    return new Response(JSON.stringify({
      success: false,
      error: error.message
    }), { 
      status: 500,
      headers: this.corsHeaders
    })
  }
}

/**
 * 处理查询钱包状态
 */
async handleWalletStatus(request, env) {
  try {
    const url = new URL(request.url)
    const wallet = url.searchParams.get('wallet')
    
    if (!wallet) {
      return new Response(JSON.stringify({
        success: false,
        error: 'Missing wallet parameter'
      }), { status: 400, headers: this.corsHeaders })
    }
    
    const normalizedWallet = wallet.toLowerCase()
    const pausedWalletsKey = 'paused_wallets'
    const pausedWalletsData = await env.RPC_POOL.get(pausedWalletsKey)
    
    if (!pausedWalletsData) {
      return new Response(JSON.stringify({
        success: true,
        wallet: normalizedWallet,
        is_paused: false
      }), { 
        status: 200,
        headers: this.corsHeaders
      })
    }
    
    const pausedWallets = JSON.parse(pausedWalletsData)
    const pausedInfo = pausedWallets.find(p => 
      p.wallet.toLowerCase() === normalizedWallet
    )
    
    if (!pausedInfo) {
      return new Response(JSON.stringify({
        success: true,
        wallet: normalizedWallet,
        is_paused: false
      }), { 
        status: 200,
        headers: this.corsHeaders
      })
    }
    
    const now = Math.floor(Date.now() / 1000)
    const remaining = pausedInfo.duration - (now - pausedInfo.paused_at)
    
    if (remaining <= 0) {
      // 暂停已过期
      return new Response(JSON.stringify({
        success: true,
        wallet: normalizedWallet,
        is_paused: false
      }), { 
        status: 200,
        headers: this.corsHeaders
      })
    }
    
    return new Response(JSON.stringify({
      success: true,
      wallet: normalizedWallet,
      is_paused: true,
      paused_at: new Date(pausedInfo.paused_at * 1000).toISOString(),
      resumed_at: new Date((pausedInfo.paused_at + pausedInfo.duration) * 1000).toISOString(),
      remaining_seconds: remaining,
      reason: pausedInfo.reason
    }), { 
      status: 200,
      headers: this.corsHeaders
    })
    
  } catch (error) {
    console.error(`❌ [${WORKER_ID}] 查询钱包状态失败:`, error)
    
    return new Response(JSON.stringify({
      success: false,
      error: error.message
    }), { 
      status: 500,
      headers: this.corsHeaders
    })
  }
}
```

#### 路由注册

```javascript
export default {
  async fetch(request, env, ctx) {
    const url = new URL(request.url)
    const path = url.pathname
    
    switch (path) {
      case '/pause-wallet':
        if (request.method === 'POST') {
          return await this.handlePauseWallet(request, env)
        }
        break
        
      case '/resume-wallet':
        if (request.method === 'POST') {
          return await this.handleResumeWallet(request, env)
        }
        break
        
      case '/wallet-status':
        if (request.method === 'GET') {
          return await this.handleWalletStatus(request, env)
        }
        break
        
      // ... 其他路由 ...
    }
    
    // ... 其他处理 ...
  }
}
```

#### 用户操作流程

| 步骤 | 操作 | Worker 行为 | 说明 |
|------|------|-----------|------|
| 1 | 在前端点击"暂停保护"（5 分钟） | 检测到暂停，跳过转账 | API 调用 `POST /pause-wallet` |
| 2 | 在 APP 充值 USDT | 继续跳过 | 用户可安全充值 |
| 3 | 在 APP 启动涡轮 | 继续跳过 | 用户可启动涡轮 |
| 4 | 涡轮结束 | 继续跳过 | 用户准备转账 |
| 5 | 用户手动将代币转到安全钱包 | 继续跳过 | 用户主动操作 |
| 6 | 点击"恢复保护" | 恢复正常扫描和转账 | API 调用 `POST /resume-wallet` |
| 7 | 智能合约返还本金 | Worker 检测到代币并自动转移 | ✅ 抢先转移 |

#### 安全机制

| 安全措施 | 说明 |
|---------|------|
| ✅ 自动恢复 | 暂停时间到期自动恢复保护 |
| ✅ 手动恢复 | 用户可提前点击"恢复保护" |
| ✅ 日志记录 | 所有暂停/恢复操作记录到 Supabase |
| ✅ 次数限制 | 每天最多暂停 5 次 |
| ✅ 时长限制 | 单次暂停最长 1 小时 |
| ✅ 钱包验证 | 仅允许暂停被保护的钱包 |
| ✅ API Key 认证 | 需要有效的 API Key 才能操作 |
| ✅ 二次确认 | 前端显示确认对话框 |

#### 数据库表结构

```sql
-- 钱包暂停历史记录表
CREATE TABLE IF NOT EXISTS wallet_pause_history (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  wallet_address TEXT NOT NULL,
  action TEXT NOT NULL, -- 'pause' or 'resume'
  reason TEXT,
  remaining_seconds INTEGER,
  worker_id TEXT NOT NULL,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- 创建索引
CREATE INDEX idx_wallet_pause_history_wallet ON wallet_pause_history(wallet_address);
CREATE INDEX idx_wallet_pause_history_created_at ON wallet_pause_history(created_at);
```

---

### 方案二：白名单代币（更精细）

#### 设计思路

允许特定代币（如 wkeyDAO 本金）在钱包中停留，只在超过允许余额时转移。

#### 配置设计

```javascript
const CONFIG = {
  ALLOWED_TOKENS: {
    '0x194B302a4b0a79795Fb68E2ADf1B8c9eC5ff8d1F': {
      name: 'wkeyDAO-本金',
      allowAccumulate: true,  // 允许累计
      minBalance: 0,          // 最小余额
      maxBalance: 1000        // 最大余额（单位：代币数量）
    },
    '0x55d398326f99059fF775485246999027B3197955': {
      name: 'USDT',
      allowAccumulate: false, // 不允许累计
      minBalance: 0,
      maxBalance: 0
    }
  }
}
```

#### 转账逻辑修改

```javascript
// 当前逻辑：检测到任何 wkeyDAO 都转移
if (wkeyDaoBalance > 0) {
  await transferWkeyDao(wallet, wkeyDaoBalance)
}

// 修改后：只在超过允许余额时转移
const allowedConfig = CONFIG.ALLOWED_TOKENS[TOKEN_WKEYDAO]
if (allowedConfig && allowedConfig.allowAccumulate) {
  if (wkeyDaoBalance > allowedConfig.maxBalance) {
    const transferAmount = wkeyDaoBalance - allowedConfig.maxBalance
    console.log(`💰 钱包 ${walletAddress.slice(-4)} wkeyDAO 超过允许余额，转移 ${transferAmount}`)
    await transferWkeyDao(wallet, transferAmount)
  } else {
    console.log(`⏸️ 钱包 ${walletAddress.slice(-4)} wkeyDAO 在允许范围内，保留`)
  }
}
```

#### 优点和缺点

| 优点 | 缺点 |
|------|------|
| ✅ 无需用户手动操作 | ❌ 需要区分"本金"和"收益" |
| ✅ 自动化程度高 | ❌ 智能合约可能混合转账 |
| ✅ 不影响正常保护 | ❌ 盗币者可能伪装成本金 |
| ✅ 配置灵活 | ❌ 需要调整阈值参数 |

---

### 方案三：手动转账窗口期（安全）

#### 设计思路

用户主动开启"手动转账窗口"，在此期间 Worker 暂停转账，但继续扫描和记录。

#### API 设计

##### 1. 开启手动窗口

**端点**: `POST /open-manual-window`

**请求参数**:
```json
{
  "wallet": "0x1234567890abcdef1234567890abcdef12345678",
  "window": 60,
  "reason": "接收本金转账"
}
```

**响应**:
```json
{
  "success": true,
  "wallet": "0x1234567890abcdef1234567890abcdef12345678",
  "window_started_at": "2026-02-02T10:00:00Z",
  "window_ends_at": "2026-02-02T10:01:00Z",
  "duration": 60
}
```

#### Worker 逻辑

```javascript
// 检查是否有手动窗口期
const manualWindowKey = `manual_window:${walletAddress}`
const manualWindowData = await env.RPC_POOL.get(manualWindowKey)

if (manualWindowData) {
  const { startedAt, duration, reason } = JSON.parse(manualWindowData)
  const now = Math.floor(Date.now() / 1000)
  const remaining = startedAt + duration - now
  
  if (remaining > 0) {
    console.log(`🪟 钱包 ${walletAddress.slice(-4)} 处于手动窗口期，剩余 ${remaining} 秒 (原因: ${reason})`)
    
    // 跳过转账，但继续扫描和记录
    await recordManualWindow(env, walletAddress, remaining, reason)
    
    return { action: 'manual_window', remaining, reason }
  } else {
    // 窗口已关闭
    console.log(`🪟 钱包 ${walletAddress.slice(-4)} 手动窗口已关闭`)
    await env.RPC_POOL.delete(manualWindowKey)
  }
}

// 继续正常扫描和转账逻辑
```

#### 用户操作流程

| 步骤 | 操作 | Worker 行为 | 说明 |
|------|------|-----------|------|
| 1 | 点击"开启手动窗口"（60 秒） | 暂停转账，继续扫描 | API 调用 `POST /open-manual-window` |
| 2 | 在 60 秒内执行所有手动操作 | 继续跳过转账 | ✅ 充值 USDT、启动涡轮、接收本金 |
| 3 | 窗口自动关闭 | 恢复自动转账 | Worker 抢先转移剩余代币 |

#### 安全增强

| 安全措施 | 说明 |
|---------|------|
| ✅ 单次窗口限制 | 每天最多 3 次手动窗口 |
| ✅ 总时长限制 | 每天最多 10 分钟手动窗口 |
| ✅ IP 限制 | 仅允许管理 IP 操作 |
| ✅ 日志记录 | 所有窗口操作记录到 Supabase |

---

## 🎯 推荐方案组合

### 最佳实践：方案一 + 方案三

**实现理由**：
1. **方案一（暂停保护）**：用于长时间操作（如启动涡轮需要较长时间）
2. **方案三（手动窗口）**：用于短时操作（如接收本金转账）

### API 端点汇总

| 端点 | 方法 | 参数 | 说明 |
|------|------|------|------|
| `/pause-wallet` | POST | `{wallet, duration, reason}` | 暂停保护（长时，最长 1 小时） |
| `/resume-wallet` | POST | `{wallet}` | 立即恢复保护 |
| `/open-manual-window` | POST | `{wallet, window, reason}` | 开启手动窗口（短时，最长 10 分钟） |
| `/wallet-status` | GET | `{wallet}` | 查询钱包保护状态 |

### 安全机制汇总

| 安全措施 | 方案一 | 方案三 |
|---------|--------|--------|
| ✅ API Key 认证 | 是 | 是 |
| ✅ 操作日志记录 | 是 | 是 |
| ✅ 每日次数限制 | 5 次 | 3 次 |
| ✅ 单次时长限制 | 1 小时 | 10 分钟 |
| ✅ 自动恢复保护 | 是 | 是 |
| ✅ 手动恢复保护 | 是 | N/A |
| ✅ 钱包验证 | 是 | 是 |
| ✅ 二次确认 | 是（前端） | 是（前端） |

---

## 📝 实施计划

### 第一阶段：实现暂停保护（方案一）

#### 1.1 数据库准备

创建 Supabase 表：
```sql
CREATE TABLE IF NOT EXISTS wallet_pause_history (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  wallet_address TEXT NOT NULL,
  action TEXT NOT NULL,
  reason TEXT,
  remaining_seconds INTEGER,
  worker_id TEXT NOT NULL,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);
```

#### 1.2 Worker 修改

- 修改 `scanWallet` 函数，添加暂停检查逻辑
- 实现 `recordPauseStatus` 和 `recordResumeStatus` 函数
- 实现 `handlePauseWallet` API 处理器
- 实现 `handleResumeWallet` API 处理器
- 实现 `handleWalletStatus` API 处理器
- 更新路由注册

#### 1.3 前端开发

- 在钱包状态页面添加"暂停保护"按钮
- 添加"恢复保护"按钮
- 显示暂停倒计时
- 显示暂停历史记录
- 添加二次确认对话框

#### 1.4 测试验证

- 测试暂停保护功能
- 测试自动恢复保护
- 测试手动恢复保护
- 测试每日次数限制
- 测试时长限制

---

### 第二阶段：实现手动窗口（方案三）

#### 2.1 Worker 修改

- 修改 `scanWallet` 函数，添加窗口检查逻辑
- 实现 `handleOpenManualWindow` API 处理器
- 更新路由注册

#### 2.2 前端开发

- 添加"开启手动窗口"按钮
- 显示窗口倒计时
- 显示窗口剩余次数
- 添加二次确认对话框

#### 2.3 测试验证

- 测试手动窗口功能
- 测试窗口自动关闭
- 测试每日次数限制
- 测试总时长限制

---

### 第三阶段：安全增强

#### 3.1 操作审计

- 记录所有 API 调用
- 记录操作 IP 地址
- 记录操作时间戳
- 添加审计日志查询 API

#### 3.2 告警机制

- 当钱包暂停超过阈值时发送告警
- 当钱包手动窗口次数过多时发送告警
- 当检测到异常操作时发送告警

#### 3.3 监控面板

- 添加钱包保护状态监控
- 添加暂停历史可视化
- 添加操作审计日志

---

## 🔒 安全评估

### 风险分析

| 风险 | 概率 | 影响 | 缓解措施 |
|------|------|------|---------|
| 盗币者利用暂停保护 | 低 | 高 | API Key 认证、IP 限制、次数限制 |
| 用户忘记恢复保护 | 中 | 中 | 自动恢复、到期告警 |
| 暂停时间过长 | 低 | 低 | 时长限制（1 小时） |
| 恶意频繁暂停 | 低 | 中 | 每日次数限制（5 次） |
| 手动窗口滥用 | 低 | 中 | 每日时长限制（10 分钟） |

### 威胁模型

| 威胁 | 应对措施 |
|------|---------|
| 盗币者获取 API Key | 定期轮换 API Key、IP 白名单 |
| 盗币者钓鱼用户 | 二次确认、操作验证 |
| 用户操作失误 | 二次确认、操作回滚 |
| Worker 故障 | 双 Worker 冗余、告警机制 |

---

## 📊 性能影响

### KV 操作增加

| 操作 | 频率 | 影响 |
|------|------|------|
| 检查暂停状态 | 每分钟/钱包 | 极小（字符串比较） |
| 更新暂停状态 | 用户操作时 | 极小（JSON 序列化） |
| 记录暂停历史 | 每次操作 | 极小（Supabase 写入） |

### 代码规模增加

| 模块 | 新增代码行数 |
|------|------------|
| 暂停检查逻辑 | ~50 行 |
| API 处理器 | ~200 行 |
| 数据库记录 | ~50 行 |
| **总计** | **~300 行** |

### 执行时间增加

| 操作 | 原始时间 | 新增时间 | 增加 |
|------|---------|---------|------|
| 单次钱包扫描 | ~50 ms | +1 ms | +2% |
| 暂停检查 | - | <1 ms | - |

**结论**：性能影响可忽略不计（+2%）

---

## 📚 参考资料

### 相关文档

- [v2.4.1-前端开发规划.md](./v2.4.1-前端开发规划.md) - 前端开发规划
- [Worker-Integrated-Pool-架构设计.md](./V2/Worker-Integrated-Pool-架构设计.md) - Worker 架构设计

### API 文档

- `/workspace/cloudflare/integrated-pool-2/src/index.js` - Worker 源码
- `/workspace/frontend/js/api.js` - 前端 API 调用

---

**文档创建日期**: 2026-02-02  
**最后更新**: 2026-02-02  
**状态**: 设计完成，待实施
