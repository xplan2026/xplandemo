# 错误 #007 - 前端自动退出登录

**日期**: 2025-01-XX  
**组件**: 前端 / 后端  
**版本**: v1.0 之前

---

## 错误信息

```
Error: 地址不在白名单中
Error: 无效或过期的 Token
用户登录后短时间内自动退出
```

---

## 影响范围

- [x] 功能异常
- [ ] 资产损失
- [ ] 性能下降
- [x] 用户体验影响

---

## 失败分析

1. **前端自动登录**: 页面加载时自动调用后端 API 登录
   - `onMounted` 钩子自动调用登录逻辑
   - 页面刷新后触发自动登录
   - 用户未主动操作

2. **硬编码白名单**: 前端 `checkWhitelist` 使用硬编码占位符地址
   ```javascript
   const MOCK_ADDRESS = '0x0000000000000000000000000000000000000000'
   const isInWhitelist = checkWhitelist(walletAddress)  // 总是返回 false
   ```

3. **后端缺少登录接口**: 后端没有 `/api/auth/nonce` 和 `/api/auth/login` 接口
   - 前端调用 API 时返回 404
   - 无法完成登录流程
   - 用户无法正常使用

4. **后端未集成 Supabase 白名单验证**: 无法查询实际白名单
   - 白名单存储在 Supabase 中
   - 后端没有查询逻辑
   - 无法验证地址是否在白名单中

---

## 改进措施

**版本**: v1.0.1

### 1. 移除自动登录逻辑

```javascript
// frontend/src/main.js
// 原有逻辑（自动登录）
onMounted(async () => {
  const wallet = await connectWallet()
  if (wallet) {
    await login(wallet)  // ❌ 自动登录
  }
})

// 改进后逻辑（需要用户点击）
async function handleConnectWallet() {
  const wallet = await connectWallet()
  await login(wallet)  // ✅ 用户主动登录
}

// 模板
<template>
  <button @click="handleConnectWallet">连接 MetaMask</button>
</template>
```

**改进说明**:
- 移除 `onMounted` 中的自动登录
- 用户必须点击"连接 MetaMask"按钮
- 避免页面刷新导致自动登录

### 2. 添加后端登录接口

```javascript
// cloudflare-worker/src/index.js

// 获取 nonce
GET /api/auth/nonce?address=0x...
Response: { nonce: "random_string" }

// 处理登录
POST /api/auth/login
Body: {
  "address": "0x...",
  "nonce": "...",
  "signature": "0x..."
}
Response: {
  "token": "jwt_token",
  "role": "admin"
}
```

**实现代码**:

```javascript
// 获取 nonce
async function getNonce(address) {
  // 生成随机 nonce
  const nonce = crypto.randomUUID()
  
  // 存储到 KV（5分钟过期）
  await env.KV.put(`auth:nonce:${address}`, nonce, {
    expirationTtl: 300
  })
  
  return { nonce }
}

// 处理登录
async function login(address, nonce, signature) {
  // 1. 验证 nonce
  const storedNonce = await env.KV.get(`auth:nonce:${address}`)
  if (storedNonce !== nonce) {
    throw new Error('Invalid nonce')
  }
  
  // 2. 验证签名
  const recoveredAddress = ethers.verifyMessage(nonce, signature)
  if (recoveredAddress.toLowerCase() !== address.toLowerCase()) {
    throw new Error('Invalid signature')
  }
  
  // 3. 查询白名单
  const whitelistResponse = await fetch(
    `${env.SUPABASE_URL}/rest/v1/whitelist?address=eq.${address.toLowerCase()}&select=*`,
    {
      headers: {
        'apikey': env.SUPABASE_KEY,
        'Authorization': `Bearer ${env.SUPABASE_KEY}`
      }
    }
  )
  
  if (!whitelistResponse.ok || whitelistResponse.data.length === 0) {
    throw new Error('地址不在白名单中')
  }
  
  // 4. 生成 JWT token
  const role = whitelistResponse.data[0].role
  const token = jwt.sign(
    { sub: address, role: role },
    env.JWT_SECRET,
    { expiresIn: '24h' }
  )
  
  return { token, role }
}
```

### 3. 集成 Supabase 白名单验证

```javascript
// 查询白名单表
const whitelistResponse = await fetch(
  `${env.SUPABASE_URL}/rest/v1/whitelist?address=eq.${address.toLowerCase()}&select=*`,
  {
    headers: {
      'apikey': env.SUPABASE_KEY,
      'Authorization': `Bearer ${env.SUPABASE_KEY}`
    }
  }
)

if (!whitelistResponse.ok || whitelistResponse.data.length === 0) {
  return { valid: false, error: '地址不在白名单中' }
}

// 返回用户角色
const role = whitelistResponse.data[0].role
const token = generateJWT(address, role)
```

**白名单表结构**:

```sql
-- supabase/create_whitelist.sql
CREATE TABLE whitelist (
  id BIGSERIAL PRIMARY KEY,
  address VARCHAR(42) NOT NULL UNIQUE,
  role VARCHAR(20) NOT NULL DEFAULT 'viewer',
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- 插入白名单地址
INSERT INTO whitelist (address, role) VALUES
  ('0x...', 'admin'),
  ('0x...', 'viewer');
```

### 4. 添加 JWT Token 验证

```javascript
// 业务 API 需要验证 token
function verifyToken(token) {
  try {
    const decoded = jwt.verify(token, env.JWT_SECRET)
    return { 
      valid: true, 
      address: decoded.sub, 
      role: decoded.role 
    }
  } catch (error) {
    return { valid: false, error: '无效或过期的Token' }
  }
}

// 在 API 中使用
GET /api/wallets
Headers: Authorization: Bearer {token}

async function handleGetWallets(request, env) {
  const authHeader = request.headers.get('Authorization')
  const token = authHeader.replace('Bearer ', '')
  
  const { valid, address, role } = verifyToken(token)
  if (!valid) {
    return new Response(JSON.stringify({ error: 'Unauthorized' }), { status: 401 })
  }
  
  // 继续处理请求...
}
```

---

## 改进验证

| 测试场景 | 输入 | 预期结果 | 实际结果 |
|----------|------|----------|----------|
| 白名单用户登录 | 白名单地址 | 登录成功，返回 token | ✅ 通过 |
| 非白名单用户登录 | 非白名单地址 | 拒绝登录 | ✅ 通过 |
| Token 验证 | 有效 Token | 允许访问 | ✅ 通过 |
| Token 过期 | 过期 Token | 拒绝访问 | ✅ 通过 |
| 页面刷新 | 已登录用户 | 保持登录状态 | ✅ 通过 |

---

## 相关文件

- `frontend/src/main.js` - 前端主逻辑
- `cloudflare-worker/src/index.js` - 后端主逻辑
- `supabase/create_whitelist.sql` - 白名单表创建
- `docs/开发指南/LOGIN_FIX.md` - 登录修复文档

---

## 经验总结

1. **用户体验**:
   - 不要自动登录，让用户主动选择
   - 避免页面刷新导致登录状态丢失
   - 提供明确的登录/登出操作

2. **白名单验证**:
   - 使用数据库存储白名单，不要硬编码
   - 登录时验证地址是否在白名单中
   - 返回用户角色，区分权限

3. **JWT Token**:
   - 使用 JWT 进行身份验证
   - 设置合理的过期时间（24 小时）
   - 业务 API 需要验证 token
   - Token 存储在 localStorage 中

4. **安全性**:
   - 使用 nonce 防止重放攻击
   - 验证签名确保地址所有权
   - Token 过期后需要重新登录

---

**最后更新**: 2025-01-XX
