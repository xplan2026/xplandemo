# 统一应急状态策略说明

## 日期
2026-01-19

---

## 背景

按照优化方案《workers进程与协作优化方案.md》，需要实现统一的应急状态策略，解决Worker-2/3/4触发应急状态后没有消费者的问题。

---

## 核心设计

### 1. 应急状态触发者

| Worker | 触发条件 | 触发方式 |
|--------|---------|---------|
| **Worker-2** | 定时任务到达触发时间 | 写入`EMERGENCY_STORE` |
| **Worker-3** | 盗币者向被保护地址转入BNB | 写入`EMERGENCY_STORE` |
| **Worker-4** | 涡轮合约向被保护地址转入wkeyDAO | 写入`EMERGENCY_STORE` |

### 2. 应急状态消费者

| Worker | 消费方式 | 执行动作 |
|--------|---------|---------|
| **Worker-1** | 每分钟检查`EMERGENCY_STORE` | 进入应急循环并转账 |

### 3. Worker-1的特殊设计

Worker-1同时支持两种工作模式：

**模式1：直接转账（不进入应急状态）**
- 触发条件：BNB增加 或 wkeyDAO余额>0
- 执行动作：直接调用`TransferManager.emergencyTransfer()`
- 优点：快速响应，无延迟

**模式2：应急状态消费**
- 触发条件：检测到`EMERGENCY_STORE`中有应急状态
- 执行动作：进入应急循环，高频扫描并转账
- 优点：统一处理，支持分布式锁

---

## 数据流程

```
┌─────────────────────────────────────────────────────────────────┐
│                    应急状态数据流程                          │
├─────────────────────────────────────────────────────────────────┤
│                                                              │
│  Worker-2 (定时任务) ─┐                                    │
│                        ├── 写入 EMERGENCY_STORE              │
│  Worker-3 (盗币者) ────┤   {                              │
│                        │     triggered: true,               │
│  Worker-4 (涡轮合约) ───┤     triggerSource: 'worker-x',    │
│                        │     triggeredAt: '...',             │
│                        │     walletAddress: '0x...'         │
│                        │   }                               │
│                        │                                    │
│                        └── Worker-1 检查 EMERGENCY_STORE  │
│                                    │                        │
│                                    ▼                        │
│                       进入应急循环 (5秒/次)                 │
│                       扫描余额 → 转账 → 记录               │
│                       超时或完成 → 清理KV                  │
│                                                              │
└─────────────────────────────────────────────────────────────────┘
```

---

## 应急状态结构

```json
{
  "triggered": true,
  "triggerSource": "worker-3-surveillance",
  "triggerReason": "thief_transfer_detected",
  "triggeredAt": "2026-01-19T12:30:00Z",
  "walletAddress": "0x123...",
  "transferDetails": {
    "from": "0x4A01...",
    "to": "0x123...",
    "value": "0.5",
    "blockNumber": 12345678,
    "txHash": "0xabc..."
  }
}
```

---

## KV命名空间统一

| Worker | KV绑定 | Key名称 | TTL |
|--------|--------|---------|-----|
| Worker-1 | `EMERGENCY_STORE` | `emergency_state` | 600秒（10分钟） |
| Worker-2 | `EMERGENCY_STORE` | `emergency_state` | 600秒 |
| Worker-3 | `EMERGENCY_STORE` | `emergency_state` | 600秒 |
| Worker-4 | `EMERGENCY_STORE` | `emergency_state` | 600秒 |

**优点**：
- 统一使用`EMERGENCY_STORE`
- 避免KV命名空间冲突
- 便于管理和调试

---

## Worker-1的工作流程

### 每分钟执行流程

```
1. 检查 EMERGENCY_STORE
   └─ 存在应急状态？
      ├─ 是 → 进入应急模式
      │     ├─ 执行应急循环 (5秒/次，最多10分钟)
      │     ├─ 检测wkeyDAO余额 > 0 → 转账
      │     ├─ 转账完成 → 退出应急模式
      │     └─ 清理 KV → 结束
      │
      └─ 否 → 正常扫描
            ├─ 扫描BNB和wkeyDAO余额
            ├─ BNB增加 OR wkeyDAO>0？
            │   ├─ 是 → 直接转账
            │   └─ 否 → 等待下一次扫描
            └─ 结束
```

---

## 分布式锁机制

为了防止多个Worker同时处理应急状态，实现了分布式锁：

```javascript
// EmergencyExtension.acquireLock()
// 使用 KV 存储锁状态
this.lockKey = 'emergency:global_lock'
this.lockTTL = 10 * 60 * 1000 // 10分钟
```

**工作原理**：
1. Worker-1尝试获取锁
2. 如果锁已被占用，跳过应急状态处理
3. 如果锁未占用，获取锁并执行应急循环
4. 应急状态结束后释放锁

---

## 文件修改清单

### Worker-1

**`src/index.js`**：
- 添加`_checkEmergencyState()`函数
- 添加`_clearEmergencyState()`函数
- 添加`EmergencyExtension`引用
- 在`scheduled()`中添加应急状态检查逻辑

**`wrangler.toml`**：
- 添加`EMERGENCY_STORE` KV绑定

### Worker-2

**`wrangler.toml`**：
- 已使用`EMERGENCY_STORE`，无需修改

### Worker-3

**`src/index.js`**：
- 修改`triggerEmergencyState()`函数
- 使用`EMERGENCY_STORE`而非`BLOCK_STORE`

**`wrangler.toml`**：
- KV绑定改为`EMERGENCY_STORE`

### Worker-4

**`src/index.js`**：
- 修改`triggerEmergencyState()`函数
- 使用`EMERGENCY_STORE`而非`BLOCK_STORE`

**`wrangler.toml`**：
- KV绑定改为`EMERGENCY_STORE`

---

## 配置说明

### 环境变量

所有Worker需要配置以下环境变量：

```bash
# Worker-1
EMERGENCY_SCAN_INTERVAL = 5      # 应急状态扫描间隔（秒）
EMERGENCY_MAX_DURATION = 600     # 应急状态最大时长（秒）

# Worker-3
THIEF_ADDRESS_1 = "0x4A01..."
THIEF_ADDRESS_2 = "0xF95B..."

# Worker-4
TURBINE_CONTRACT_ADDRESS = "0xa8a..."
```

### KV命名空间

所有Worker需要绑定同一个KV命名空间：

```toml
[[kv_namespaces]]
binding = "EMERGENCY_STORE"
id = "YOUR_EMERGENCY_KV_ID"
preview_id = "YOUR_PREVIEW_EMERGENCY_KV_ID"
```

---

## 测试场景

### 场景1：Worker-3触发应急状态

1. 模拟盗币者转账
2. Worker-3检测到转账
3. Worker-3写入`EMERGENCY_STORE`
4. 下一次Worker-1扫描时发现应急状态
5. Worker-1进入应急循环
6. Worker-1检测到wkeyDAO余额>0
7. Worker-1转账并退出应急状态

### 场景2：Worker-2触发应急状态

1. 用户创建定时任务
2. 任务到达触发时间
3. Worker-2写入`EMERGENCY_STORE`
4. 下一次Worker-1扫描时发现应急状态
5. Worker-1进入应急循环
6. Worker-1检测到wkeyDAO余额>0
7. Worker-1转账并退出应急状态

### 场景3：Worker-1直接转账

1. Worker-1正常扫描
2. 检测到BNB增加
3. 不进入应急状态
4. 直接调用`TransferManager`转账
5. 转账完成

---

## 优势

1. **统一管理**：所有应急状态通过同一个KV管理
2. **职责清晰**：Worker-2/3/4负责触发，Worker-1负责消费
3. **灵活响应**：Worker-1支持两种模式（直接转账 + 应急状态）
4. **分布式锁**：防止多个Worker同时处理应急状态
5. **自动清理**：应急状态完成后自动清理KV

---

## 后续优化

1. **全局调度器**（可选）
   - 实现全局scanner.js调度4个Worker
   - 顺序：Worker-3 → Worker-2 → Worker-1 → Worker-4

2. **通知功能**
   - 应急状态触发时发送通知
   - 支持Telegram、短信等渠道

3. **监控告警**
   - 监控应急状态触发频率
   - 记录异常情况
