# Cloudflare Worker 最终架构设计说明

## 一、架构概述

### 核心设计原则

1. **职责分离**：每个模块只负责单一职责，减少耦合
2. **单一转账程序**：所有转账由`TransferManager`统一执行
3. **独立应急状态**：应急状态由`EmergencyExtension`独立管理
4. **交易监控分离**：交易结果监控由`Aide`独立处理

---

## 二、模块划分

### 1. Worker-1: Interception（抢先转移）

**职责**：
- 每分钟扫描3个被保护钱包
- 检测到`wkeyDAO>0`或`BNB>0.001`时，直接调用`TransferManager`转账
- **不进入应急状态**

**触发条件**（或关系）：
1. `wkeyDAO余额>0`（优先判断）
2. `BNB余额>0.001`

**调用链**：
```
Worker-1.scheduled()
  → Scanner1.scan() 扫描余额
  → _shouldTransfer() 判断触发条件
  → _executeTransfer() 调用 TransferManager.emergencyTransfer()
  → 保存交易记录（状态: pending）
  → 调用后不管结果
```

---

### 2. Worker-2: Scheduler（定时任务）

**职责**：
- 用户通过前端创建定时任务
- 在涡轮结束前30分钟触发应急状态
- **不执行转账，只触发应急状态**

**任务流程**：
1. 用户选择被保护地址，输入涡轮开始时间
2. 系统计算触发时间 = 开始时间 + 11.5小时
3. 触发时写入`EMERGENCY_STORE`
4. 任务标记为完成

**调用链**：
```
Worker-2.scheduled()
  → 检查pending任务
  → 触发任务到达 → triggerEmergencyState()
  → 写入 EMERGENCY_STORE
  → 记录到数据库
```

---

### 3. Worker-3: Surveillance（监控盗币者钱包）

**职责**：
- 监控盗币者钱包
- 检测到盗币者向被保护钱包转入BNB时，触发应急状态
- **不执行转账，只触发应急状态**

**触发条件**：
- 盗币者钱包在过去1分钟内有向被保护钱包转入BNB的交易记录

**调用链**：
```
Worker-3.scheduled()
  → 查询盗币者钱包交易记录（TransactionChecker）
  → 发现向被保护钱包转账 → triggerEmergencyState()
  → 写入 EMERGENCY_STORE
```

---

### 4. Worker-4: Turbine（监控涡轮合约）

**职责**：
- 监控涡轮合约
- 检测到涡轮合约向被保护钱包转入wkeyDAO时，触发应急状态
- **不执行转账，只触发应急状态**

**触发条件**：
- 涡轮合约在过去1分钟内有向被保护钱包转入wkeyDAO的交易记录

**调用链**：
```
Worker-4.scheduled()
  → 查询涡轮合约交易记录（TransactionChecker）
  → 发现向被保护钱包转账 → triggerEmergencyState()
  → 写入 EMERGENCY_STORE
```

---

### 5. Worker-5: Emergency State（应急状态执行）

**职责**：
- 每分钟检查`EMERGENCY_STORE`
- 发现应急状态触发信号后，进入应急状态
- **5秒扫描一次3个被保护钱包**
- **只判断wkeyDAO余额是否>0**
- 检测到`wkeyDAO>0`后**立即退出**（不等待转账完成）
- 8分钟后超时退出

**分布式锁**：
- 使用`db.kv.put('emergency:global_lock')`实现
- 同时只允许一个应急状态运行

**调用链**：
```
Worker-5.scheduled()
  → 检查 EMERGENCY_STORE
  → 发现触发信号 → EmergencyExtension.enterEmergencyMode()
  → 获取分布式锁 → 成功则进入，失败则跳过
  → runEmergencyLoop() 循环扫描
  → 5秒扫描一次3个钱包
  → 检测到wkeyDAO>0 → onTransferTrigger()
  → 调用 TransferManager.emergencyTransfer()
  → 立即退出应急状态
```

---

## 三、扩展模块

### 1. TransferManager（转账管理器）

**位置**：`extensions/transfer/Transfer.js`

**职责**：
- 统一执行所有转账操作
- 先转`wkeyDAO`，再转`BNB`
- 同一个被保护钱包同一时间只有一个交易（通过调用顺序保证）

**方法**：
- `emergencyTransfer(wallet)` - 紧急转账
- `manualTransfer(wallet, token)` - 手动转账

**调用方**：
- Worker-1（直接转账）
- Worker-5（应急状态触发转账）
- GlobalScanner（可选，统一调度时调用）

---

### 2. EmergencyExtension（应急状态扩展）

**位置**：`extensions/emergency/EmergencyExtension.js`

**职责**：
- 管理应急状态生命周期
- 执行5秒扫描循环
- 提供5秒扫描3个被保护钱包的功能
- 只判断`wkeyDAO>0`，不执行转账
- **注意：分布式锁由外部DistributedLock扩展管理**

**配置**：
- `EMERGENCY_SCAN_INTERVAL`: 5秒（默认）
- `EMERGENCY_MAX_DURATION`: 480秒（8分钟）
- `PROTECTED_WALLETS`: 3个被保护钱包地址（环境变量）

**方法**：
- `enterEmergencyMode()` - 进入应急状态
- `runEmergencyLoop()` - 执行应急循环
- `exitEmergencyMode()` - 退出应急状态

---

### 3. DistributedLock（分布式锁扩展）

**位置**：`extensions/emergency/DistributedLock.js`

**职责**：
- 防止多个Worker同时触发应急状态
- 提供统一的锁管理接口
- 支持重试和强制释放

**方法**：
- `acquire(metadata)` - 获取锁
- `acquireWithRetry(metadata)` - 获取锁（带重试）
- `release()` - 释放锁
- `checkLock()` - 检查锁状态
- `forceRelease()` - 强制释放锁（谨慎使用）

**调用方**：
- Worker-5（应急状态执行前获取锁）
- GlobalScanner（可选，统一调度时使用）

**锁的生命周期**：
1. Worker-5尝试进入应急状态时获取
2. 应急状态正常退出时释放
3. 应急状态超时（8分钟）时释放
4. 10分钟后自动过期（兜底）

---

### 4. Aide（交易监控器）

**位置**：`extensions/transfer/aide.js`

**职责**：
- 监控交易是否成功
- 失败时检查钱包余额
- 如果`wkeyDAO>0`，再次触发转账

**监控逻辑**：
- 每5秒检查一次交易状态
- 最多等待60秒
- 最多重试3次
- 失败后扫描钱包，`wkeyDAO>0`则重试

**方法**：
- `monitorTransaction(txHash, walletAddress)` - 监控交易

---

### 5. GlobalScanner（全局调度器）

**位置**：`extensions/scanner/GlobalScanner.js`

**职责**：
- 统一调度4个Worker的scanner
- 按照顺序执行：Worker-3 → Worker-2 → Worker-1 → Worker-4
- 每分钟完成一个完整冲程
- 错误处理和重试机制

**方法**：
- `initialize()` - 初始化扫描器
- `runGlobalSchedule()` - 执行全局调度
- `_runScanner(scannerKey)` - 运行单个扫描器

**调用方**：
- 可选：如果需要统一调度，可以在某个Worker中调用

**特点**：
- 顺应盗币流程的时间线
- 每分钟完成一个完整冲程
- 单个扫描器失败不影响其他扫描器

---

## 四、数据流程

### 正常流程（Worker-1触发）

```
1. Worker-1每分钟扫描
   ↓
2. 检测到wkeyDAO>0或BNB>0.001
   ↓
3. 调用TransferManager.emergencyTransfer()
   ↓
4. 保存交易记录（状态: pending）
   ↓
5. Aide监控交易结果
   ↓
6. 交易成功 → 完成
   交易失败 → 检查wkeyDAO>0 → 重试转账
```

### 应急流程（Worker-2/3/4触发）

```
1. Worker-2/3/4检测到触发条件
   ↓
2. 写入EMERGENCY_STORE
   ↓
3. Worker-5每分钟检查EMERGENCY_STORE
   ↓
4. 发现触发信号，获取分布式锁
   ↓
5. 进入应急状态，5秒扫描一次3个钱包
   ↓
6. 检测到wkeyDAO>0
   ↓
7. 调用TransferManager.emergencyTransfer()
   ↓
8. 立即退出应急状态
   ↓
9. Aide监控交易结果（同正常流程）
```

---

## 五、分布式锁设计

### 锁的目的
防止多个Worker同时触发应急状态，导致资源冲突

### 锁的实现
**位置**：`extensions/emergency/DistributedLock.js`

**存储方式**：
- 优先使用KV存储（`env.EMERGENCY_STORE`）
- 备用：数据库存储（`distributed_locks`表）

**使用示例**：
```javascript
import { createDistributedLock } from '../../extensions/emergency/DistributedLock.js'

const lock = createDistributedLock(env, db, {
  workerId: 'worker-5-emergency-state'
})

// 获取锁（带重试）
const acquired = await lock.acquireWithRetry({
  source: 'worker-3-surveillance',
  reason: 'thief_transfer_detected'
})

if (acquired) {
  try {
    // 执行应急状态
    await emergency.enterEmergencyMode()
    await emergency.runEmergencyLoop()
  } finally {
    // 确保释放锁
    await lock.release()
  }
}

// 检查锁状态
const lockStatus = await lock.checkLock()
console.log('Lock status:', lockStatus)

// 强制释放锁（谨慎使用）
await lock.forceRelease()
```

### 锁的方法
- `acquire(metadata)` - 获取锁（单次尝试）
- `acquireWithRetry(metadata)` - 获取锁（最多重试3次）
- `release()` - 释放锁
- `checkLock()` - 检查锁状态
- `forceRelease()` - 强制释放锁

### 锁的生命周期
1. Worker-5尝试进入应急状态时获取
2. 应急状态正常退出时释放
3. 应急状态超时（8分钟）时释放
4. 10分钟后自动过期（兜底）

### 锁的优势
1. **扩展方式**：独立扩展，便于排查错误和统一协调
2. **灵活部署**：单个Worker逐一部署，不依赖其他Worker
3. **重试机制**：支持自动重试，提高成功率
4. **降级策略**：获取锁失败时允许继续执行（避免阻塞）
5. **API接口**：提供HTTP API查询锁状态和强制释放

---

## 六、交易单一性保证

### 同一被保护钱包
- **保证方式**：调用顺序
  - Worker-1和Worker-5不会同时运行
  - Worker-1每分钟运行一次，Worker-5进入应急状态后阻塞
- **实际效果**：同一被保护钱包同一时间只有一个交易

### 不同被保护钱包
- **允许并发**：可以同时有多个交易
- **场景**：盗币者使用机器人同时操作3个被保护钱包

---

## 七、环境变量配置

### 通用配置（所有Worker）
```bash
SUPABASE_URL=your_supabase_url
SUPABASE_KEY=your_supabase_key
JWT_SECRET=your_jwt_secret
BSC_RPC=your_bsc_rpc_url
TOKEN_WKEYDAO=0x194B302a4b0a79795Fb68E2ADf1B8c9eC5ff8d1F
SAFE_WALLET=your_safe_wallet_address
```

### 应急状态配置（Worker-5）
```bash
EMERGENCY_SCAN_INTERVAL=5          # 5秒扫描间隔
EMERGENCY_MAX_DURATION=480         # 8分钟最大时长
PROTECTED_WALLETS=wallet1,wallet2,wallet3
```

### KV配置（所有Worker）
```toml
[[kv_namespaces]]
binding = "EMERGENCY_STORE"
id = "your_kv_namespace_id"
```

---

## 八、关键设计决策

### 1. 为什么Worker-1不进入应急状态？
- Worker-1是"抢先转移"策略，快速响应
- 应急状态由Worker-5统一管理，职责清晰
- Worker-1调用后不管结果，由Aide监控

### 2. 为什么应急状态不执行转账？
- 职责分离：应急状态只负责检测
- 转账由TransferManager统一执行
- Aide负责监控和重试

### 3. 为什么应急状态只判断wkeyDAO？
- BNB转账由Worker-1处理（每分钟扫描）
- 应急状态专注于wkeyDAO检测（高频）
- 避免重复逻辑

### 4. 为什么使用分布式锁？
- Worker-2/3/4可能同时触发应急状态
- 锁保证同一时间只有一个应急状态运行
- 降低系统负载，避免资源冲突

### 5. 为什么应急状态超时8分钟？
- Cloudflare Worker免费额度限制
- 5秒扫描 × 96次 = 8分钟
- 288次RPC调用（3个钱包 × 96次）
- 在可接受范围内

---

## 九、全局调度器（可选功能）

### 调用顺序
按照盗币流程的时间线设计，每分钟完成一个完整冲程：

```
Worker-3（监控盗币者钱包）
    ↓
Worker-2（检查定时任务）
    ↓
Worker-1（扫描被保护钱包）
    ↓
Worker-4（监控涡轮合约）
```

### 全局调度器的优势
1. **统一管理**：所有scanner在一个调度器中管理
2. **顺序执行**：顺应盗币流程的时间线
3. **错误隔离**：单个scanner失败不影响其他scanner
4. **性能优化**：减少Cloudflare Worker调用次数

### 使用方式
**方式1：独立Worker部署**
```javascript
// 在独立Worker中使用
import { createGlobalScanner } from '../extensions/scanner/GlobalScanner.js'

export default {
  async scheduled(event, env) {
    const db = new DatabaseExtension(env)
    const scanner = createGlobalScanner(env, db, {
      workerId: 'global-scanner'
    })

    await scanner.initialize()
    await scanner.runGlobalSchedule()
  }
}
```

**方式2：在现有Worker中使用**
```javascript
// 在Worker-1或其他Worker中使用
import { createGlobalScanner } from '../extensions/scanner/GlobalScanner.js'

export default {
  async scheduled(event, env) {
    const db = new DatabaseExtension(env)

    // 使用全局调度器替代独立扫描
    const scanner = createGlobalScanner(env, db, {
      workerId: 'worker-1'
    })

    await scanner.initialize()
    await scanner.runGlobalSchedule()
  }
}
```

### 配置要求
```bash
# 盗币者钱包列表（Worker-3使用）
THIEF_WALLETS=0x4A01eFCdA6d077A8AF6555Aa83Bc11E7be093561,0xF95B911a3d26b076a10aC726Fde5D800972104B4

# 被保护钱包列表（所有scanner使用）
PROTECTED_WALLETS=wallet1,wallet2,wallet3

# 涡轮合约地址（Worker-4使用）
TURBINE_CONTRACT=0xa8aCdd81F46633b69AcB6ec5c16Ee7E00cc8938D
```

---

## 十、总结

### 架构优势
1. ✅ **职责清晰**：每个模块只负责单一职责
2. ✅ **转账统一**：所有转账由TransferManager统一执行
3. ✅ **监控独立**：交易监控由Aide独立处理
4. ✅ **状态管理**：应急状态由EmergencyExtension统一管理
5. ✅ **并发控制**：分布式锁防止资源冲突（独立扩展）
6. ✅ **调用分离**：Worker调用转账后不管结果
7. ✅ **灵活部署**：扩展方式便于排查错误和协调
8. ✅ **全局调度**：可选的全局调度器统一管理scanner

### 关键特点
- Worker-1：直接转账，不进入应急状态
- Worker-2/3/4：触发应急状态，不执行转账
- Worker-5：执行应急状态，检测wkeyDAO>0后退出
- TransferManager：统一转账执行
- Aide：独立交易监控
- DistributedLock：独立分布式锁扩展
- GlobalScanner：可选的全局调度器

### 部署建议
1. **单个Worker逐一部署**：便于排查错误
2. **扩展模块独立管理**：DistributedLock和GlobalScanner作为扩展
3. **全局调度器可选**：根据需要选择使用独立调度或分散调度

---

**文档版本**: v2.0
**最后更新**: 2026-01-19
